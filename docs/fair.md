# 公平锁

公平锁（Fair Lock）是一种加锁机制，确保所有请求按顺序排队获取锁。谁先来，谁先拿到锁，遵循 FIFO（先进先出）原则。
与之相对的是非公平锁（Unfair Lock），谁能抢到谁就先用，可能导致部分请求长期得不到锁，造成“饥饿”现象。

**举个例子**

假设有 3 个线程同时竞争一个锁，如果调度策略是非公平的，线程 A 每次都能抢先获得锁，而线程 C 每次都晚一步被抢走机会。长期如此，C 可能一直得不到执行机会，导致“饥饿”。

想象你在医院排队挂号：
- 公平锁就像是取了号排队：前面排的人没处理完，你永远轮不到。
- 非公平锁就像是你每隔几分钟去窗口碰碰运气，如果你运气好、手快，就插队成功了。

## 公平锁是如何避免饥饿现象的
公平锁（Fair Lock）的关键在于**遵循“先来先服务”（FIFO）原则**：谁先请求锁，谁就先获得锁。这样可以保证每个请求最终都会排到前面，**不会永远被其他后来的请求插队抢占**。

## 公平锁 VS 非公平锁
| **特性**     | **公平锁**                   | **非公平锁**                       |
| ------------ | ---------------------------- | ---------------------------------- |
| 排队顺序     | FIFO，按请求顺序             | 不保证顺序，谁先抢到谁拿到         |
| 是否可能饥饿 | 否（理论上不会）             | 是，有可能某些请求长时间得不到锁   |
| 性能         | 性能略差（排队/调度有成本）  | 性能较好，适合低冲突、高吞吐场景   |
| 适用场景     | 抢票、限流等强调“公平”的场景 | 高并发数据库连接池、线程池任务调度 |


## Redis公平锁的实现原理
### 数据结构设计
基于 Redis 的两个关键特性

| **Redis Key**    | **用途**                               |
| ---------------- | -------------------------------------- |
| lock:{key}       | 真正的锁标识（存放持有锁的 requestId） |
| lock:{key}:queue | ZSET 有序集合，用于排队请求者          |


### 加锁流程（FairLock）
```
-- 核心逻辑（伪代码）
ZADD queue 当前时间 requestId         // 加入队列
ZRANK 判断是否是队首
SET lock_key requestId NX PX ttl     // 只有队首才尝试抢锁
```

### 步骤解析
1. 排队：请求到来时，加入一个 ZSET 队列，分数为当前时间（毫秒）。
2. 超时清理：在每次加锁时清除超时队列成员，防止队列堆积。
3. 判断是否是队首：
   - 是队首 → 尝试加锁。
   - 否 → 返回失败，由调用方决定是否重试。
4. 抢锁成功：设置 Redis 的键值（SET NX PX），将 lock:{key} 设置为自己的 requestId。
5. 启动自动续期（可选）：后台协程定期续约，防止锁被自动过期。

