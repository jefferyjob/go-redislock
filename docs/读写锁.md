# 读写锁设计文档
本文档详细说明了基于 Redis 的读写锁实现，包括实现原理、锁状态、流程、事件和 Lua 脚本逻辑。

## 锁的设计目标

1. 读写分离：
   * 多个读者可以并发持有读锁。
   * 写者独占锁，写锁存在时阻止其他读/写锁获取。

2. 可重入：
   * 同一持有者可重复加读锁或写锁。
   * 持有写锁的同一持有者可以同时获取读锁。
   * 允许从“仅自己在读”升级到写锁。

3. 租约机制：
   * 锁设置 TTL（毫秒）保证超时自动释放。
   * 支持续期操作刷新 TTL。

4. 原子性：
   * 所有状态判断和更新通过单条 Lua 脚本完成，避免竞态。

5. 可观测性：
   * 脚本返回值统一，用于判断成功、失败和剩余 TTL。


## 锁的数据结构

使用 Redis Hash 存储单个资源锁状态，结构如下：

| 字段名      | 类型     | 说明                            |
|----------| ------ | ----------------------------- |
| mode     | string | 锁模式: "read" 或 "write"，不存在表示空闲 |
| rcount   | int    | 总读者数                          |
| r:{uuid} | int    | 某个持有者的读锁可重入计数                 |
| writer   | string | 当前写锁持有者 ID（仅 write 模式存在）      |
| wcount   | int    | 写锁可重入计数（仅 write 模式存在）         |

**uuid**: 当前使用 `github.com/google/uuid` 获取唯一标识。


## 锁状态流程图

### 读锁流程图
#### 读锁加锁流程（RLock）

```mermaid
flowchart TD
    A[开始 RLock] --> B[获取锁 key 数据]
    B --> C{锁是否存在?}
    C -- 否 --> D[设置 mode=read, rcount=1, r:owner=1]
    D --> E[设置 TTL]
    E --> F[返回成功]
    C -- 是 --> G{mode == read?}
    G -- 是 --> H[自身 r:owner+1, rcount+1]
    H --> I[刷新 TTL]
    I --> F
    G -- 否 --> J{mode == write 且 writer == owner?}
    J -- 是 --> K[允许重入：r:owner+1, rcount+1]
    K --> I
    J -- 否 --> L[返回失败]
    L --> F
```

#### 读锁解锁流程（RUnLock）

```mermaid
flowchart TD
    A[开始 RUnLock] --> B[获取 r:owner 计数]
    B --> C{self_cnt <= 0?}
    C -- 是 --> D[返回失败]
    C -- 否 --> E[self_cnt-1, rcount-1]
    E --> F{self_cnt == 0?}
    F -- 是 --> G[删除 r:owner 字段]
    F -- 否 --> H[继续]
    H --> I[获取总 rcount]
    I --> J{rcount <=0 ?}
    J -- 是 --> K{mode == read ?}
    K -- 是 --> L[DEL key]
    K -- 否 --> M[HDEL rcount]
    J -- 否 --> N[保持锁]
    L --> O[返回成功]
    M --> O
    N --> O
```

#### 读锁续期流程（RRenew）

```mermaid
flowchart TD
    A[开始 RRenew] --> B[获取 r:owner 计数]
    B --> C{self_cnt <= 0?}
    C -- 是 --> D[返回失败]
    C -- 否 --> E[刷新 TTL]
    E --> F[返回成功]
```

### 写锁流程图
#### 写锁加锁流程（WLock）

```mermaid
flowchart TD
    A[开始 WLock] --> B[获取锁 key 数据]
    B --> C{锁是否存在?}
    C -- 否 --> D[设置 mode=write, writer=owner, wcount=1]
    D --> E[设置 TTL]
    E --> F[返回成功]
    C -- 是 --> G{mode == write 且 writer == owner?}
    G -- 是 --> H[wcount+1, 刷新 TTL]
    H --> F
    G -- 否 --> I{mode == read 且 rcount == r:owner?}
    I -- 是 --> J[升级锁：mode=write, writer=owner, wcount=1]
    J --> E
    I -- 否 --> K[返回失败]
    K --> F
```

#### 写锁解锁流程（WUnLock）

```mermaid
flowchart TD
    A[开始 WUnLock] --> B[获取 writer]
    B --> C{writer != owner?}
    C -- 是 --> D[返回失败]
    C -- 否 --> E[wcount-1]
    E --> F{wcount>0?}
    F -- 是 --> G[返回成功]
    F -- 否 --> H[删除 writer, wcount]
    H --> I[获取 rcount]
    I --> J{rcount>0?}
    J -- 是 --> K[切回 read mode]
    J -- 否 --> L[DEL key]
    K --> M[返回成功]
    L --> M
```

#### 写锁续期流程（WRenew）

```mermaid
flowchart TD
    A[开始 WRenew] --> B[获取 writer]
    B --> C{writer != owner?}
    C -- 是 --> D[返回失败]
    C -- 否 --> E[刷新 TTL]
    E --> F[返回成功]
```

### 其他情况流程图
#### 读锁加锁遇到写锁流程
```mermaid
flowchart TD
    A[开始 RLock] --> B[获取锁 key 数据]
    B --> C{mode == write?}
    C -- 否 --> D[按正常读锁流程处理]
    C -- 是 --> E[获取 writer]
    E --> F{writer == owner?}
    F -- 是 --> G[允许重入：r:owner+1, rcount+1]
    G --> H[刷新 TTL]
    H --> I[返回成功]
    F -- 否 --> J[无法获取读锁]
    J --> K[返回失败]
```

#### 写锁加锁遇到读锁流程
```mermaid
flowchart TD
    A[开始 WLock] --> B[获取锁 key 数据]
    B --> C{mode == read?}
    C -- 否 --> D[按正常写锁流程处理]
    C -- 是 --> E[获取 rcount 和自身 r:owner]
    E --> F{rcount == r:owner?}
    F -- 是 --> G[升级锁：mode=write, writer=owner, wcount=1]
    G --> H[刷新 TTL]
    H --> I[返回成功]
    F -- 否 --> J[存在其他读者，无法获取写锁]
    J --> K[返回失败]
```

## 锁操作事件
| 操作      | 条件/逻辑说明                             |
| ------- | ----------------------------------- |
| RLock   | 空闲或读锁模式时成功；写锁模式下若持有者为自己也成功，否则失败     |
| RUnLock | 自身读锁计数减 1；若总读者数为 0 且无写锁则删除锁键        |
| WLock   | 空闲时成功；持有写锁者可重入；读模式且仅自己读时可升级为写锁；否则失败 |
| WUnLock | 写计数减 1；归零时若有读者则切回读锁，否则删除锁键          |
| RRenew  | 刷新 TTL，仅当持有读锁的 owner 调用成功           |
| WRenew  | 刷新 TTL，仅当持有写锁的 owner 调用成功           |


## 注意事项
1. **uuid 唯一性**：确保每个客户端/线程使用唯一 uuid，避免破坏可重入计数。
2. **租期策略**：TTL 由 Redis 管理，客户端可以使用续期看门狗策略保持锁。
3. **升级与降级**：读锁可升级为写锁仅限“仅自己读”；写锁降级为读锁在写计数归零时自动处理。
4. **高并发优化**：单键结构在高并发场景下可能成为热点，可按资源做分片或使用 Lua 脚本保证原子性。
5. **异常恢复**：客户端崩溃后锁会自动过期，确保不会永久阻塞其他线程。
