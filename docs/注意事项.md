# 注意事项

### ⚠️ 使用注意事项（建议仔细阅读）

使用 `go-redislock` 时，为确保锁机制稳定可靠，请注意以下要点：

#### 🔑 锁使用原则

* 每次加锁操作应使用新的 `RedisLock` / `ReadWriteLock` / `MultiLock` 实例，**避免复用导致状态混乱**。
* 加锁与解锁必须使用**完全相同的 key 和 token**，确保一致性。
* 使用 `defer lock.UnLock(ctx)` 是推荐的释放锁方式，**确保异常情况下也能自动释放**。

#### ⏱ 锁超时与续期

* 默认 TTL 为 5 秒，**请根据业务实际耗时设置合理 TTL**，避免锁提前失效。
* 开启 `WithAutoRenew()` 自动续期时，务必确保业务逻辑无长时间阻塞，否则可能导致续期失败、锁被意外释放。
* 手动续期需主动调用 `Renew(ctx)`，适用于自定义续期逻辑场景。

#### ⚖️ 公平锁使用建议

* 公平锁通过队列顺序排队获取，**需传入唯一请求 ID（如 UUID）**，以区分不同请求。
* 公平锁适用于高并发场景下，需保障请求获取顺序和等待公平性。

#### 🧵 读写锁注意事项

* **读锁可并发，但写锁互斥**：确保不会出现“读写冲突”或“写写冲突”。
* 避免读锁阻塞时间过长，可能导致写锁长时间无法获取。

#### 🔗 联锁（MultiLock）注意事项

* 联锁内部会尝试依次加锁所有资源，**任意一个失败都会释放已获取的锁**。
* 所有子锁需使用不同的 key，防止死锁或误解锁。
* 加锁成功后仍需使用 `Unlock()` 统一释放。

#### 📡 Redis 服务要求

* 确保 Redis 服务稳定可用，开启持久化和主从复制可进一步提升可靠性。
* 在分布式环境中，建议 Redis 实例部署在同一局域网内，**降低延迟和网络分区风险**。

#### 🧪 建议测试与监控

* 对锁相关的关键业务流程进行充分测试，排查竞态和死锁问题。
* 在生产环境中建议对锁的获取失败、重试、自旋耗时等行为进行监控，**及时发现潜在问题**。


## 常见误用示例

* **重复使用同一个锁实例**：

```go
lock := New(rdb, "key")
lock.Lock(ctx)
lock.Lock(ctx) // ❌ 不建议复用同一实例
```

* **未正确解锁**（如异常退出）：

```go
lock.Lock(ctx)
// defer lock.UnLock(ctx) ❌ 忘记解锁，可能造成死锁
```

* **公平锁未传 requestId**：

```go
lock.FairLock(ctx, "") // ❌ requestId 必须唯一
```

* **TTL 过短，业务未执行完锁就失效**：

```go
WithTimeout(1 * time.Second) // ❌ 业务耗时远超 1s
```

* **联锁子 key 重复**：

```go
NewMultiLock("same_key", "same_key") // ❌ 子锁应唯一
```

### 🛠 如何排查锁相关问题
* ✅ **加锁失败**：检查 Redis 是否连通、key 是否已被其他实例持有。
* ✅ **无法解锁**：确认解锁时的 token 是否与加锁时一致。
* ✅ **公平锁无效**：确认是否使用唯一 requestId，是否等待超时。
* ✅ **锁提前释放**：检查 TTL 设置是否合理，自动续期是否生效。
* ✅ **死锁/资源卡住**：查看是否未解锁、续期失败或锁资源使用冲突。
* ✅ **联锁失败**：确认是否某个子锁获取失败、子 key 是否重复。
